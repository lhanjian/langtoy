%{
    my %prog_root = ( "kind" => "prog", "func" => [], "expr" => [] );
    sub getrootref { \%prog_root }
%}

%token LPAREN
%token RPAREN
%token LAMBDA
%token COLON
%token NUMLITERAL
%token STRLITERAL
%token IDENT

%%

program: form_list
;

form_list: 
| form_list form
;

form: func_defn { push $prog_root{"func"}, $_[1]; $_[1] }
| expr { push $prog_root{"expr"}, $_[1]; $_[1] }
;

func_defn: LAMBDA IDENT abstraction {
    my $node = { "kind" => "func", "name" => $_[2], "body" => $_[3] };
    $node
}
;

expr: LPAREN abstraction RPAREN { my $node = { "kind" => "expr", "body" => $_[2] }; $node }
| LPAREN application RPAREN { my $node = { "kind" => "expr", "body" => $_[2] }; $node }
;

abstraction: COLON param_list expr {
    my $node = { "kind" => "abst", "param" => $_[2], "body" => $_[3] };
    $node
}
;

param_list: ident_list { 
    my $node = { "kind" => "param-list", "body" => $_[1] };
    $node
}
;

ident_list: { [] }
| IDENT ident_list { my $sublist = $_[2]; my @list = ($_[1], @$sublist); \@list }
;

application: term arg_list {
    my $node = { "kind" => "appl", "op" => $_[1], "arglist" => $_[2] };
    $node
}
;

arg_list: term_list { my $node = { "kind" => "arg-list", "body" => $_[1] }; $node }
;

literal: STRLITERAL | NUMLITERAL;

term_list: { [] }
| term term_list { my $sublist = $_[2]; my @list= ($_[1], @$sublist); \@list }
;

term: expr { $_[1] }
| IDENT {
    my $node = { "kind" => "ident", "val" => $_[1] };
    $node
}
| literal {
    my $node = { "kind" => "literal", "val" => $_[1] };
    $node
}
;

%%
